from datetime import datetime
from enum import Enum
from typing import Any, Optional
from uuid import UUID
from pathlib import Path

from pydantic import BaseModel, EmailStr, Field


def to_camel(snake_str: str) -> str:
    """Convert snake_case to camelCase"""
    components = snake_str.split("_")
    return components[0] + "".join(x.title() for x in components[1:])


class SchemaBase(BaseModel):
    class Config:
        populate_by_name = True
        alias_generator = to_camel


DEFAULT_SEARCH_LIMIT = 3


class Role(str, Enum):
    """Defines the role of the message author in a conversation."""

    SYSTEM = "system"
    USER = "user"
    ASSISTANT = "assistant"


class FinishReason(str, Enum):
    """Reason why the generation stopped."""

    STOP = "stop"
    LENGTH = "length"
    CONTENT_FILTER = "content_filter"


class Message(SchemaBase):
    """A message in a conversation between user and assistant."""

    # The role of the message author
    role: Role

    # The content of the message
    content: str

    # Optional name identifying the message author
    name: Optional[str] = None


class GenerationOptions(SchemaBase):
    """Options that control the text generation process."""

    # The maximum number of tokens to generate
    max_tokens: Optional[int] = None

    # The number of tokens to sample from the top of the distribution
    temperature: Optional[float] = Field(None, ge=0.0, le=2.0)

    # Nucleus sampling parameter
    top_p: Optional[float] = Field(None, ge=0.0, le=1.0)

    # Sequences that will stop generation if encountered
    stop_sequences: Optional[list[str]] = None

    # Whether to return log probabilities of the generated tokens
    logprobs: Optional[bool] = None

    # The number of tokens to sample from the top of the distribution
    top_logprobs: Optional[int] = None

    # Extensions for the generation options
    extensions: Optional[dict[str, Any]] = Field(
        default=None, description="Container for specification extensions"
    )


class ChatUsage(SchemaBase):
    """Token usage information for the request and response."""

    # The number of tokens in the prompt
    prompt_tokens: int

    # The number of tokens in the generated text
    completion_tokens: int

    # The total number of tokens used in the request and response
    total_tokens: int


class LogProbs(SchemaBase):
    """Log probabilities for generated tokens."""

    # Map of tokens to their log probabilities
    token_logprobs: dict[str, float] = Field(
        description="Map of tokens to their log probabilities"
    )


class ChatResponse(SchemaBase):
    """Response from a chat completion request."""

    # The ID of the response (using UUID instead of string)
    id: UUID

    # Name of the model used for generation
    model: str

    # The message generated by the assistant
    message: Message

    # Reason why the generation stopped
    finish_reason: Optional[FinishReason] = None

    # Token usage information
    usage: ChatUsage

    # Provider-specific information
    provider_info: Optional[dict[str, Any]] = None

    # Log probabilities for generated tokens
    logprobs: Optional[LogProbs] = None

    # Cost of the request
    cost: Optional[float] = None


class ChatRequest(SchemaBase):
    """Parameters for chat completion generation."""

    # The model identifier to use for chat
    model: str

    # Array of message objects representing the conversation
    messages: list[Message]

    # Additional parameters for the generation
    options: Optional[GenerationOptions] = None


class SearchOptions(SchemaBase):
    """Options for controlling document retrieval process"""

    # Maximum number of documents to search
    limit: Optional[int] = Field(
        default=DEFAULT_SEARCH_LIMIT,
        description="Maximum number of documents to search",
    )

    # Minimum similarity score for searched documents
    similarity_threshold: Optional[float] = Field(
        default=None,
        description="Minimum similarity score for searched documents",
        ge=0,
        le=1,
    )

    # Whether to include document metadata in results
    include_metadata: Optional[bool] = Field(
        default=None, description="Whether to include document metadata in results"
    )

    # Whether to include vector embeddings in results
    include_embeddings: Optional[bool] = Field(
        default=None, description="Whether to include vector embeddings in results"
    )

    # Container for searcher-specific extensions
    extensions: Optional[dict[str, Any]] = Field(
        default=None, description="Container for searcher-specific extensions"
    )


class DocumentResult(SchemaBase):
    """A document searched from the index"""

    # Identifier for the document
    id: str = Field(..., description="Identifier for the document")

    # Similarity score between query and document
    score: float = Field(..., description="Similarity score between query and document")

    # Text content of the document or chunk
    content: str = Field(..., description="Text content of the document or chunk")

    # Metadata associated with the document
    metadata: Optional[dict[str, Any]] = Field(
        default=None, description="Metadata associated with the document"
    )

    # Vector embedding of the document (if requested)
    embedding: Optional[list[float]] = Field(
        default=None, description="Vector embedding of the document (if requested)"
    )


class SearchRequest(SchemaBase):
    """Parameters for document search request."""

    # The user email
    user_email: EmailStr = Field(..., description="The user email")

    # The search query
    query: str = Field(..., description="The search query")

    # Additional parameters for the search
    options: Optional[SearchOptions] = Field(
        default=SearchOptions(), description="Additional parameters for the search"
    )

    # Transaction token
    transaction_token: Optional[str] = Field(
        default=None, description="Transaction token"
    )


class SearchResponse(SchemaBase):
    """The result of the document search operation"""

    # Unique identifier for this search operation
    id: UUID = Field(..., description="Unique identifier for this search operation")

    # The original search query
    query: str = Field(..., description="The original search query")

    # Search results matching the query
    results: list[DocumentResult] = Field(
        ..., description="Search results matching the query"
    )

    # Router-specific information
    provider_info: Optional[dict[str, Any]] = Field(
        default=None, description="Router-specific information"
    )

    # Cost of the request
    cost: Optional[float] = None


class PricingChargeType(str, Enum):
    """The type of charge for a service"""

    # The service is charged per request
    PER_REQUEST = "per_request"


class RouterServiceType(str, Enum):
    CHAT = "chat"
    SEARCH = "search"

    @classmethod
    def all_types(cls):
        return [service.value for service in cls]


class ServiceOverview(SchemaBase):
    """Overview of a service provided by the router"""

    # The type of service
    type: RouterServiceType

    # The pricing of the service
    pricing: float

    # The charge type of the service
    charge_type: PricingChargeType = Field(default=PricingChargeType.PER_REQUEST)

    # Whether the service is enabled
    enabled: bool


class PublishedMetadata(SchemaBase):
    """Metadata for a published project."""

    # Name of the project
    project_name: str = Field(..., description="Name of the project")

    # Description of the project
    description: str = Field(..., description="Project description")

    # Summary of the project
    summary: str = Field(..., description="Project summary")

    # Tags of the project
    tags: list[str] = Field(default_factory=list, description="Project tags")

    # Services provided by the project
    services: list[ServiceOverview] = Field(
        default_factory=list, description="Pricing information"
    )

    # SHA256 hash of all Python files
    code_hash: str = Field(..., description="SHA256 hash of all Python files")

    # Version of the project
    version: str = Field(..., description="Project version")

    # API endpoints documentation
    documented_endpoints: Optional[dict[str, Any]] = Field(
        None, description="API endpoints documentation"
    )

    # Publication date
    publish_date: datetime = Field(..., description="Publication date")

    # Author email
    author: str = Field(..., description="Author email")

    # Path to RPC schema file
    schema_path: Optional[str] = Field(None, description="Path to RPC schema file")

    @classmethod
    def from_path(cls, metadata_path: Path) -> "PublishedMetadata":
        return cls.model_validate_json(metadata_path.read_text())
